[
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "ansi_fg256",
        "importPath": "textAnimator.colors",
        "description": "textAnimator.colors",
        "isExtraImport": true,
        "detail": "textAnimator.colors",
        "documentation": {}
    },
    {
        "label": "linear_gradient",
        "importPath": "textAnimator.colors",
        "description": "textAnimator.colors",
        "isExtraImport": true,
        "detail": "textAnimator.colors",
        "documentation": {}
    },
    {
        "label": "rgb_to_ansi256",
        "importPath": "textAnimator.colors",
        "description": "textAnimator.colors",
        "isExtraImport": true,
        "detail": "textAnimator.colors",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "IntFlag",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "asynccontextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "TextAnimator",
        "importPath": "textAnimator",
        "description": "textAnimator",
        "isExtraImport": true,
        "detail": "textAnimator",
        "documentation": {}
    },
    {
        "label": "Style",
        "importPath": "textAnimator",
        "description": "textAnimator",
        "isExtraImport": true,
        "detail": "textAnimator",
        "documentation": {}
    },
    {
        "label": "MODES",
        "importPath": "textAnimator.modes",
        "description": "textAnimator.modes",
        "isExtraImport": true,
        "detail": "textAnimator.modes",
        "documentation": {}
    },
    {
        "label": "AnimatorFlags",
        "importPath": "textAnimator.flags",
        "description": "textAnimator.flags",
        "isExtraImport": true,
        "detail": "textAnimator.flags",
        "documentation": {}
    },
    {
        "label": "Color",
        "importPath": "textAnimator.ansi",
        "description": "textAnimator.ansi",
        "isExtraImport": true,
        "detail": "textAnimator.ansi",
        "documentation": {}
    },
    {
        "label": "MultiTextAnimator",
        "importPath": "textAnimator.multiline",
        "description": "textAnimator.multiline",
        "isExtraImport": true,
        "detail": "textAnimator.multiline",
        "documentation": {}
    },
    {
        "label": "MultiTextMode",
        "importPath": "textAnimator.multiline",
        "description": "textAnimator.multiline",
        "isExtraImport": true,
        "detail": "textAnimator.multiline",
        "documentation": {}
    },
    {
        "label": "TextConfig",
        "importPath": "textAnimator.multiline",
        "description": "textAnimator.multiline",
        "isExtraImport": true,
        "detail": "textAnimator.multiline",
        "documentation": {}
    },
    {
        "label": "TextAnimator",
        "kind": 6,
        "importPath": "textAnimator.animator",
        "description": "textAnimator.animator",
        "peekOfCode": "class TextAnimator:\n    \"\"\"\n    Master controller.\n    \"\"\"\n    def __call__(\n        self,\n        text: str | None = None,\n        mode: Union[\n            Literal[\"typewriter\", \"marquee\", \"bounce\", \"scramble\", \"slide\"],\n            MODES,",
        "detail": "textAnimator.animator",
        "documentation": {}
    },
    {
        "label": "PaintType",
        "kind": 5,
        "importPath": "textAnimator.animator",
        "description": "textAnimator.animator",
        "peekOfCode": "PaintType = Union[\n    tuple[int,int,int],                       # single RGB\n    Sequence[tuple[int,int,int]],             # per-character list/tuple\n    tuple[tuple[int,int,int], tuple[int,int,int]],  # gradient start/end\n    Callable[[str], Iterable[tuple[int,int,int]]],  # callable returning colors\n    None\n]\nclass TextAnimator:\n    \"\"\"\n    Master controller.",
        "detail": "textAnimator.animator",
        "documentation": {}
    },
    {
        "label": "Color",
        "kind": 6,
        "importPath": "textAnimator.ansi",
        "description": "textAnimator.ansi",
        "peekOfCode": "class Color(Enum):\n    BLACK = (0, 0, 0)\n    RED = (255, 0, 0)\n    GREEN = (0, 255, 0)\n    YELLOW = (255, 255, 0)\n    BLUE = (0, 0, 255)\n    MAGENTA = (255, 0, 255)\n    CYAN = (0, 255, 255)\n    WHITE = (255, 255, 255)\nclass Style(Enum):",
        "detail": "textAnimator.ansi",
        "documentation": {}
    },
    {
        "label": "Style",
        "kind": 6,
        "importPath": "textAnimator.ansi",
        "description": "textAnimator.ansi",
        "peekOfCode": "class Style(Enum):\n    BOLD = \"\\033[1m\"\n    ITALIC = \"\\033[3m\"\n    UNDERLINE = \"\\033[4m\"\n    RESET = \"\\033[0m\"\ndef apply_gradient(text: str, colors: Iterable[tuple[int,int,int]] | list[tuple[int,int,int]]) -> str:\n    \"\"\"\n    Apply per-character colors to text\n    colors: list of RGB tuples matching length of text\n    \"\"\"",
        "detail": "textAnimator.ansi",
        "documentation": {}
    },
    {
        "label": "apply_gradient",
        "kind": 2,
        "importPath": "textAnimator.ansi",
        "description": "textAnimator.ansi",
        "peekOfCode": "def apply_gradient(text: str, colors: Iterable[tuple[int,int,int]] | list[tuple[int,int,int]]) -> str:\n    \"\"\"\n    Apply per-character colors to text\n    colors: list of RGB tuples matching length of text\n    \"\"\"\n    colors = list(colors)  # ensure len() works\n    if len(text) != len(colors):\n        raise ValueError(\"Text length must equal colors length\")\n    result = \"\"\n    for ch, (r,g,b) in zip(text, colors):",
        "detail": "textAnimator.ansi",
        "documentation": {}
    },
    {
        "label": "apply_style",
        "kind": 2,
        "importPath": "textAnimator.ansi",
        "description": "textAnimator.ansi",
        "peekOfCode": "def apply_style(text: str, *codes: Style) -> str:\n    if not codes:\n        return text\n    return \"\".join([code.value for code in codes]) + text + Style.RESET.value",
        "detail": "textAnimator.ansi",
        "documentation": {}
    },
    {
        "label": "rgb_to_ansi256",
        "kind": 2,
        "importPath": "textAnimator.colors",
        "description": "textAnimator.colors",
        "peekOfCode": "def rgb_to_ansi256(r: int, g: int, b: int) -> int:\n    \"\"\"\n    Convert 0-255 RGB to nearest 256-color ANSI index\n    \"\"\"\n    r = max(0, min(5, int(r / 256 * 6)))\n    g = max(0, min(5, int(g / 256 * 6)))\n    b = max(0, min(5, int(b / 256 * 6)))\n    return 16 + 36 * r + 6 * g + b\ndef ansi_fg256(index: int) -> str:\n    return f\"\\033[38;5;{index}m\"",
        "detail": "textAnimator.colors",
        "documentation": {}
    },
    {
        "label": "ansi_fg256",
        "kind": 2,
        "importPath": "textAnimator.colors",
        "description": "textAnimator.colors",
        "peekOfCode": "def ansi_fg256(index: int) -> str:\n    return f\"\\033[38;5;{index}m\"\ndef ansi_bg256(index: int) -> str:\n    return f\"\\033[48;5;{index}m\"\n# -----------------------\n# ColorSpace conversions\n# -----------------------\ndef from_rgb(r: int, g: int, b: int) -> tuple[int, int, int]:\n    return (r, g, b)\ndef from_hex(hexstr: str) -> tuple[int, int, int]:",
        "detail": "textAnimator.colors",
        "documentation": {}
    },
    {
        "label": "ansi_bg256",
        "kind": 2,
        "importPath": "textAnimator.colors",
        "description": "textAnimator.colors",
        "peekOfCode": "def ansi_bg256(index: int) -> str:\n    return f\"\\033[48;5;{index}m\"\n# -----------------------\n# ColorSpace conversions\n# -----------------------\ndef from_rgb(r: int, g: int, b: int) -> tuple[int, int, int]:\n    return (r, g, b)\ndef from_hex(hexstr: str) -> tuple[int, int, int]:\n    hexstr = hexstr.lstrip(\"#\")\n    return (int(hexstr[0:2], 16), int(hexstr[2:4], 16), int(hexstr[4:6], 16))",
        "detail": "textAnimator.colors",
        "documentation": {}
    },
    {
        "label": "from_rgb",
        "kind": 2,
        "importPath": "textAnimator.colors",
        "description": "textAnimator.colors",
        "peekOfCode": "def from_rgb(r: int, g: int, b: int) -> tuple[int, int, int]:\n    return (r, g, b)\ndef from_hex(hexstr: str) -> tuple[int, int, int]:\n    hexstr = hexstr.lstrip(\"#\")\n    return (int(hexstr[0:2], 16), int(hexstr[2:4], 16), int(hexstr[4:6], 16))\ndef from_hsv(h: float, s: float, v: float) -> tuple[int, int, int]:\n    \"\"\"\n    HSV to RGB conversion, h in [0,360], s,v in [0,1]\n    \"\"\"\n    h = h % 360",
        "detail": "textAnimator.colors",
        "documentation": {}
    },
    {
        "label": "from_hex",
        "kind": 2,
        "importPath": "textAnimator.colors",
        "description": "textAnimator.colors",
        "peekOfCode": "def from_hex(hexstr: str) -> tuple[int, int, int]:\n    hexstr = hexstr.lstrip(\"#\")\n    return (int(hexstr[0:2], 16), int(hexstr[2:4], 16), int(hexstr[4:6], 16))\ndef from_hsv(h: float, s: float, v: float) -> tuple[int, int, int]:\n    \"\"\"\n    HSV to RGB conversion, h in [0,360], s,v in [0,1]\n    \"\"\"\n    h = h % 360\n    s = max(0, min(1, s))\n    v = max(0, min(1, v))",
        "detail": "textAnimator.colors",
        "documentation": {}
    },
    {
        "label": "from_hsv",
        "kind": 2,
        "importPath": "textAnimator.colors",
        "description": "textAnimator.colors",
        "peekOfCode": "def from_hsv(h: float, s: float, v: float) -> tuple[int, int, int]:\n    \"\"\"\n    HSV to RGB conversion, h in [0,360], s,v in [0,1]\n    \"\"\"\n    h = h % 360\n    s = max(0, min(1, s))\n    v = max(0, min(1, v))\n    c = v * s\n    x = c * (1 - abs((h / 60) % 2 - 1))\n    m = v - c",
        "detail": "textAnimator.colors",
        "documentation": {}
    },
    {
        "label": "linear_gradient",
        "kind": 2,
        "importPath": "textAnimator.colors",
        "description": "textAnimator.colors",
        "peekOfCode": "def linear_gradient(start_rgb: tuple[int,int,int], end_rgb: tuple[int,int,int], n: int) -> list[tuple[int,int,int]]:\n    gradient = []\n    for i in range(n):\n        r = int(start_rgb[0] + (end_rgb[0] - start_rgb[0]) * i / max(n-1, 0.00001))\n        g = int(start_rgb[1] + (end_rgb[1] - start_rgb[1]) * i / max(n-1, 0.00001))\n        b = int(start_rgb[2] + (end_rgb[2] - start_rgb[2]) * i / max(n-1, 0.00001))\n        gradient.append((r,g,b))\n    return gradient  # type list",
        "detail": "textAnimator.colors",
        "documentation": {}
    },
    {
        "label": "Event",
        "kind": 6,
        "importPath": "textAnimator.events",
        "description": "textAnimator.events",
        "peekOfCode": "class Event:\n    \"\"\"\n    A simple async event dispatcher.\n    `.emit(data)` notifies listeners.\n    `async with event.wait():` waits for the next emission.\n    \"\"\"\n    def __init__(self):\n        self._listeners = []\n        self._waiters = []\n    def connect(self, func):",
        "detail": "textAnimator.events",
        "documentation": {}
    },
    {
        "label": "RepeatEvent",
        "kind": 6,
        "importPath": "textAnimator.events",
        "description": "textAnimator.events",
        "peekOfCode": "class RepeatEvent(Event):\n    \"\"\"\n    Fires automatically every frame (e.g. every iteration of animator loop).\n    Animator must call .trigger_frame() each frame.\n    \"\"\"\n    async def trigger_frame(self, frame_data=None):\n        await self.emit(frame_data)\ndef on(event: Event):\n    def wrapper(func: Callable):\n        event.connect(func)",
        "detail": "textAnimator.events",
        "documentation": {}
    },
    {
        "label": "on",
        "kind": 2,
        "importPath": "textAnimator.events",
        "description": "textAnimator.events",
        "peekOfCode": "def on(event: Event):\n    def wrapper(func: Callable):\n        event.connect(func)\n        return func\n    return wrapper",
        "detail": "textAnimator.events",
        "documentation": {}
    },
    {
        "label": "AnimatorFlags",
        "kind": 6,
        "importPath": "textAnimator.flags",
        "description": "textAnimator.flags",
        "peekOfCode": "class AnimatorFlags(IntFlag):\n    NoFlags = 0\n    HideCursor = auto()          # Hide terminal cursor during animation\n    ClearLineBefore = auto()      # Clear line before each frame\n    ClearScreenBefore = auto()    # Clear entire terminal before start\n    ClearScreenAfter = auto()     # Clear entire terminal after complete\n    KeepLastFrame = auto()        # After finishing, leave last frame (no cleanup)\n    AutoNewline = auto()          # Print newline after animation stops\n    ErasePreviousFrame = auto()   # Clear previous printed frame",
        "detail": "textAnimator.flags",
        "documentation": {}
    },
    {
        "label": "MODES",
        "kind": 6,
        "importPath": "textAnimator.modes",
        "description": "textAnimator.modes",
        "peekOfCode": "class MODES(Enum):\n    TYPEWRITER = \"typewriter\"\n    MARQUEE = \"marquee\"\n    BOUNCE = \"bounce\"\n    SCRAMBLE = \"scramble\"\n# Dynamic registry\n_mode_handlers: Dict[str, Callable] = {}\ndef register_mode(name: str):\n    \"\"\"\n    Decorator version:",
        "detail": "textAnimator.modes",
        "documentation": {}
    },
    {
        "label": "register_mode",
        "kind": 2,
        "importPath": "textAnimator.modes",
        "description": "textAnimator.modes",
        "peekOfCode": "def register_mode(name: str):\n    \"\"\"\n    Decorator version:\n    @register_mode(\"reversewave\")\n    async def reverse_wave(text):\n        ...\n    \"\"\"\n    def wrapper(func: Callable):\n        _mode_handlers[name] = func\n        return func",
        "detail": "textAnimator.modes",
        "documentation": {}
    },
    {
        "label": "get_mode",
        "kind": 2,
        "importPath": "textAnimator.modes",
        "description": "textAnimator.modes",
        "peekOfCode": "def get_mode(name: str):\n    # Try enum\n    try:\n        return MODES(name.upper())\n    except Exception:\n        pass\n    # Try dynamic mode\n    if name in _mode_handlers:\n        return _mode_handlers[name]\n    raise ValueError(f\"Unknown mode: {name}\")",
        "detail": "textAnimator.modes",
        "documentation": {}
    },
    {
        "label": "MultiTextMode",
        "kind": 6,
        "importPath": "textAnimator.multiline",
        "description": "textAnimator.multiline",
        "peekOfCode": "class MultiTextMode(Enum):\n    \"\"\"Multi-line animation coordination modes\"\"\"\n    SIMULTANEOUS = \"simultaneous\"  # All lines animate at the same time\n    STAGGERED = \"staggered\"        # Lines animate with delay between each\n    SEQUENTIAL = \"sequential\"       # Lines animate one after another (wait for completion)\nclass TextConfig:\n    \"\"\"Configuration for a single line in multi-line animation\"\"\"\n    def __init__(self,\n            text: str,\n            mode: Union[",
        "detail": "textAnimator.multiline",
        "documentation": {}
    },
    {
        "label": "TextConfig",
        "kind": 6,
        "importPath": "textAnimator.multiline",
        "description": "textAnimator.multiline",
        "peekOfCode": "class TextConfig:\n    \"\"\"Configuration for a single line in multi-line animation\"\"\"\n    def __init__(self,\n            text: str,\n            mode: Union[\n                Literal[\"typewriter\", \"marquee\", \"bounce\", \"scramble\", \"slide\"], MODES, str\n            ] = MODES.TYPEWRITER,\n            interval: float = 0.05,\n            paint: PaintType = None,\n            style=None,",
        "detail": "textAnimator.multiline",
        "documentation": {}
    },
    {
        "label": "_TextConfigurator",
        "kind": 6,
        "importPath": "textAnimator.multiline",
        "description": "textAnimator.multiline",
        "peekOfCode": "class _TextConfigurator:\n    \"\"\"\n    Configurator for individual line animations in MultiTextAnimator.\n    Allows per-line modification through indexing like: animator[0](paint=(255, 0, 0))\n    \"\"\"\n    def __init__(self, multiline_animator: 'MultiTextAnimator', text_index: int):\n        self.__multiline__ = multiline_animator\n        self.__text_index__ = text_index\n    def __call__(\n        self,",
        "detail": "textAnimator.multiline",
        "documentation": {}
    },
    {
        "label": "MultiTextAnimator",
        "kind": 6,
        "importPath": "textAnimator.multiline",
        "description": "textAnimator.multiline",
        "peekOfCode": "class MultiTextAnimator:\n    \"\"\"\n    Multi-line text animator with synchronized coordination.\n    Extends TextAnimator functionality to handle multiple lines with:\n    - Simultaneous: All lines animate together\n    - Staggered: Lines start with delays\n    - Sequential: Lines animate one after another\n    - Per-line customization: Each line can have its own mode, colors, style\n    - Individual line control: Use animator[0] for per-line configuration\n    Example:",
        "detail": "textAnimator.multiline",
        "documentation": {}
    },
    {
        "label": "animator",
        "kind": 5,
        "importPath": "test1",
        "description": "test1",
        "peekOfCode": "animator = TextAnimator(\n    \"HELLO WORLD!\",\n    mode=\"reverse_writer\",\n    interval=0.005,\n    paint=Color.GREEN.value,\n    style=Style.BOLD,\n    flags=AnimatorFlags.HideCursor\n)\nasyncio.run(animator.start())\nwhile True:",
        "detail": "test1",
        "documentation": {}
    },
    {
        "label": "animator",
        "kind": 5,
        "importPath": "test2",
        "description": "test2",
        "peekOfCode": "animator = MultiTextAnimator(texts=[\"Line 1\", \"Line 2\"])\n# Method chaining works!\nanimator[0](\"hello\", \"typewriter\", paint=(255, 0, 0))\nanimator[1](\"world\", \"slide\", paint=(0, 0, 255))\nasyncio.run(animator.start())",
        "detail": "test2",
        "documentation": {}
    }
]